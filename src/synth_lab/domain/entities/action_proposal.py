"""
ActionProposal value object for LLM-assisted scenario exploration.

Represents a proposal generated by the LLM for improving a scenario.
Contains the action description, category, rationale, and estimated impacts.

References:
    - Spec: specs/024-llm-scenario-exploration/spec.md
    - Data model: specs/024-llm-scenario-exploration/data-model.md
"""

from typing import Self

from pydantic import BaseModel, Field, field_validator, model_validator

# Valid categories from the action catalog
VALID_CATEGORIES = {
    "ux_interface",
    "onboarding",
    "flow",
    "communication",
    "operational",
}

# Valid impact parameters
VALID_IMPACT_PARAMS = {
    "complexity",
    "initial_effort",
    "perceived_risk",
    "time_to_value",
}

# Impact value range
MIN_IMPACT = -0.10
MAX_IMPACT = 0.10


class ActionProposal(BaseModel):
    """
    A proposal for improving a scenario, generated by the LLM.

    Attributes:
        action: Description of the concrete action (max 500 chars)
        category: Category from the action catalog
        rationale: Short justification for the action (max 200 chars)
        impacts: Dictionary of parameter deltas {param: delta}
    """

    action: str = Field(
        max_length=500,
        description="Description of the concrete action.",
    )

    category: str = Field(
        description="Category from the action catalog.",
    )

    rationale: str = Field(
        max_length=200,
        description="Short justification for the action.",
    )

    impacts: dict[str, float] = Field(
        description="Dictionary of parameter deltas.",
    )

    @field_validator("action")
    @classmethod
    def validate_action_not_empty(cls, v: str) -> str:
        """Ensure action is not empty."""
        if not v or not v.strip():
            raise ValueError("action cannot be empty")
        return v.strip()

    @field_validator("category")
    @classmethod
    def validate_category(cls, v: str) -> str:
        """Ensure category is valid."""
        if v not in VALID_CATEGORIES:
            raise ValueError(
                f"Invalid category: {v}. Must be one of: {', '.join(sorted(VALID_CATEGORIES))}"
            )
        return v

    @field_validator("rationale")
    @classmethod
    def validate_rationale_not_empty(cls, v: str) -> str:
        """Ensure rationale is not empty."""
        if not v or not v.strip():
            raise ValueError("rationale cannot be empty")
        return v.strip()

    @field_validator("impacts")
    @classmethod
    def validate_impacts(cls, v: dict[str, float]) -> dict[str, float]:
        """Validate impacts dictionary."""
        if not v:
            raise ValueError("impacts cannot be empty")

        for param, delta in v.items():
            if param not in VALID_IMPACT_PARAMS:
                raise ValueError(
                    f"Invalid impact parameter: {param}. "
                    f"Must be one of: {', '.join(sorted(VALID_IMPACT_PARAMS))}"
                )
            if delta < MIN_IMPACT or delta > MAX_IMPACT:
                raise ValueError(
                    f"Impact for {param} must be between {MIN_IMPACT} and {MAX_IMPACT}, got {delta}"
                )

        return v

    @model_validator(mode="after")
    def validate_at_least_one_nonzero_impact(self) -> Self:
        """Ensure at least one impact is non-zero."""
        if all(abs(v) < 0.001 for v in self.impacts.values()):
            raise ValueError("At least one impact must be non-zero")
        return self


def parse_llm_proposals(response_json: list[dict]) -> list[ActionProposal]:
    """
    Parse LLM response into ActionProposal objects.

    Validates each proposal and skips invalid ones.

    Args:
        response_json: List of proposal dictionaries from LLM

    Returns:
        List of valid ActionProposal objects
    """
    proposals = []
    for item in response_json:
        try:
            proposal = ActionProposal(
                action=item.get("action", ""),
                category=item.get("category", ""),
                rationale=item.get("rationale", ""),
                impacts=item.get("impacts", {}),
            )
            proposals.append(proposal)
        except (ValueError, TypeError):
            # Skip invalid proposals
            continue
    return proposals


if __name__ == "__main__":
    import sys

    all_validation_failures = []
    total_tests = 0

    # Test 1: Create valid proposal
    total_tests += 1
    try:
        proposal = ActionProposal(
            action="Adicionar tooltip contextual no fluxo de checkout",
            category="ux_interface",
            rationale="Reduz friccao cognitiva no momento de duvida",
            impacts={"complexity": -0.02, "time_to_value": -0.01},
        )
        if proposal.action != "Adicionar tooltip contextual no fluxo de checkout":
            all_validation_failures.append(f"Action mismatch: {proposal.action}")
        if proposal.category != "ux_interface":
            all_validation_failures.append(f"Category mismatch: {proposal.category}")
    except Exception as e:
        all_validation_failures.append(f"Create valid proposal test failed: {e}")

    # Test 2: Reject empty action
    total_tests += 1
    try:
        ActionProposal(
            action="",
            category="ux_interface",
            rationale="Test",
            impacts={"complexity": -0.01},
        )
        all_validation_failures.append("Should reject empty action")
    except ValueError:
        pass  # Expected
    except Exception as e:
        all_validation_failures.append(f"Unexpected error for empty action: {e}")

    # Test 3: Reject invalid category
    total_tests += 1
    try:
        ActionProposal(
            action="Test action",
            category="invalid_category",
            rationale="Test",
            impacts={"complexity": -0.01},
        )
        all_validation_failures.append("Should reject invalid category")
    except ValueError:
        pass  # Expected
    except Exception as e:
        all_validation_failures.append(f"Unexpected error for invalid category: {e}")

    # Test 4: Accept all valid categories
    total_tests += 1
    try:
        for cat in VALID_CATEGORIES:
            proposal = ActionProposal(
                action="Test action",
                category=cat,
                rationale="Test rationale",
                impacts={"complexity": -0.01},
            )
            if proposal.category != cat:
                all_validation_failures.append(f"Category {cat} not accepted")
                break
    except Exception as e:
        all_validation_failures.append(f"Valid categories test failed: {e}")

    # Test 5: Reject impact out of range
    total_tests += 1
    try:
        ActionProposal(
            action="Test action",
            category="flow",
            rationale="Test",
            impacts={"complexity": -0.15},  # Out of range
        )
        all_validation_failures.append("Should reject impact out of range")
    except ValueError:
        pass  # Expected
    except Exception as e:
        all_validation_failures.append(f"Unexpected error for impact out of range: {e}")

    # Test 6: Reject invalid impact parameter
    total_tests += 1
    try:
        ActionProposal(
            action="Test action",
            category="flow",
            rationale="Test",
            impacts={"invalid_param": -0.01},
        )
        all_validation_failures.append("Should reject invalid impact parameter")
    except ValueError:
        pass  # Expected
    except Exception as e:
        all_validation_failures.append(f"Unexpected error for invalid impact param: {e}")

    # Test 7: Reject all-zero impacts
    total_tests += 1
    try:
        ActionProposal(
            action="Test action",
            category="flow",
            rationale="Test",
            impacts={"complexity": 0.0, "initial_effort": 0.0},
        )
        all_validation_failures.append("Should reject all-zero impacts")
    except ValueError:
        pass  # Expected
    except Exception as e:
        all_validation_failures.append(f"Unexpected error for all-zero impacts: {e}")

    # Test 8: Accept multiple impacts
    total_tests += 1
    try:
        proposal = ActionProposal(
            action="Remover etapa desnecessaria",
            category="flow",
            rationale="Simplifica o fluxo",
            impacts={
                "complexity": -0.05,
                "initial_effort": -0.03,
                "perceived_risk": 0.01,
                "time_to_value": -0.04,
            },
        )
        if len(proposal.impacts) != 4:
            all_validation_failures.append(f"Should have 4 impacts: {len(proposal.impacts)}")
    except Exception as e:
        all_validation_failures.append(f"Multiple impacts test failed: {e}")

    # Test 9: parse_llm_proposals with valid data
    total_tests += 1
    try:
        response = [
            {
                "action": "Adicionar tooltip",
                "category": "ux_interface",
                "rationale": "Ajuda usuario",
                "impacts": {"complexity": -0.02},
            },
            {
                "action": "Remover etapa",
                "category": "flow",
                "rationale": "Simplifica",
                "impacts": {"complexity": -0.03, "time_to_value": -0.02},
            },
        ]
        proposals = parse_llm_proposals(response)
        if len(proposals) != 2:
            all_validation_failures.append(f"Should parse 2 proposals: {len(proposals)}")
    except Exception as e:
        all_validation_failures.append(f"parse_llm_proposals test failed: {e}")

    # Test 10: parse_llm_proposals skips invalid
    total_tests += 1
    try:
        response = [
            {
                "action": "Valid action",
                "category": "ux_interface",
                "rationale": "Valid",
                "impacts": {"complexity": -0.02},
            },
            {
                "action": "",  # Invalid - empty action
                "category": "ux_interface",
                "rationale": "Test",
                "impacts": {"complexity": -0.02},
            },
            {
                "action": "Another action",
                "category": "invalid",  # Invalid - bad category
                "rationale": "Test",
                "impacts": {"complexity": -0.02},
            },
        ]
        proposals = parse_llm_proposals(response)
        if len(proposals) != 1:
            all_validation_failures.append(
                f"Should parse only 1 valid proposal, got {len(proposals)}"
            )
    except Exception as e:
        all_validation_failures.append(f"parse_llm_proposals skip invalid test failed: {e}")

    # Test 11: Serialization
    total_tests += 1
    try:
        proposal = ActionProposal(
            action="Test action",
            category="communication",
            rationale="Test rationale",
            impacts={"perceived_risk": -0.03},
        )
        data = proposal.model_dump()
        if data["category"] != "communication":
            all_validation_failures.append(f"Serialization category mismatch: {data['category']}")
        if data["impacts"]["perceived_risk"] != -0.03:
            all_validation_failures.append("Serialization impacts mismatch")
    except Exception as e:
        all_validation_failures.append(f"Serialization test failed: {e}")

    # Final validation result
    if all_validation_failures:
        print(f"VALIDATION FAILED - {len(all_validation_failures)} of {total_tests} tests failed:")
        for failure in all_validation_failures:
            print(f"  - {failure}")
        sys.exit(1)
    else:
        print(f"VALIDATION PASSED - All {total_tests} tests produced expected results")
        sys.exit(0)
